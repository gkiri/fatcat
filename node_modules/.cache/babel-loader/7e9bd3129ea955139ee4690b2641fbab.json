{"ast":null,"code":"import _toConsumableArray from \"/home/gude/Gkiran_Area/wbst/fatcat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlError } from \"../error\";\nexport function accountSize(idl, idlAccount) {\n  if (idlAccount.type.kind === \"enum\") {\n    var variantSizes = idlAccount.type.variants.map(function (variant) {\n      if (variant.fields === undefined) {\n        return 0;\n      }\n\n      return variant.fields // @ts-ignore\n      .map(function (f) {\n        // @ts-ignore\n        if (f.name === undefined) {\n          throw new Error(\"Tuple enum variants not yet implemented.\");\n        } // @ts-ignore\n\n\n        return typeSize(idl, f.type);\n      }).reduce(function (a, b) {\n        return a + b;\n      });\n    });\n    return Math.max.apply(Math, _toConsumableArray(variantSizes)) + 1;\n  }\n\n  if (idlAccount.type.fields === undefined) {\n    return 0;\n  }\n\n  return idlAccount.type.fields.map(function (f) {\n    return typeSize(idl, f.type);\n  }).reduce(function (a, b) {\n    return a + b;\n  });\n} // Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\n\nfunction typeSize(idl, ty) {\n  switch (ty) {\n    case \"bool\":\n      return 1;\n\n    case \"u8\":\n      return 1;\n\n    case \"i8\":\n      return 1;\n\n    case \"i16\":\n      return 2;\n\n    case \"u16\":\n      return 2;\n\n    case \"u32\":\n      return 4;\n\n    case \"i32\":\n      return 4;\n\n    case \"u64\":\n      return 8;\n\n    case \"i64\":\n      return 8;\n\n    case \"u128\":\n      return 16;\n\n    case \"i128\":\n      return 16;\n\n    case \"bytes\":\n      return 1;\n\n    case \"string\":\n      return 1;\n\n    case \"publicKey\":\n      return 32;\n\n    default:\n      // @ts-ignore\n      if (ty.vec !== undefined) {\n        return 1;\n      } // @ts-ignore\n\n\n      if (ty.option !== undefined) {\n        // @ts-ignore\n        return 1 + typeSize(idl, ty.option);\n      } // @ts-ignore\n\n\n      if (ty.defined !== undefined) {\n        // @ts-ignore\n        var filtered = idl.types.filter(function (t) {\n          return t.name === ty.defined;\n        });\n\n        if (filtered.length !== 1) {\n          throw new IdlError(\"Type not found: \".concat(JSON.stringify(ty)));\n        }\n\n        var typeDef = filtered[0];\n        return accountSize(idl, typeDef);\n      } // @ts-ignore\n\n\n      if (ty.array !== undefined) {\n        // @ts-ignore\n        var arrayTy = ty.array[0]; // @ts-ignore\n\n        var arraySize = ty.array[1]; // @ts-ignore\n\n        return typeSize(idl, arrayTy) * arraySize;\n      }\n\n      throw new Error(\"Invalid type \".concat(JSON.stringify(ty)));\n  }\n} // Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\n\n\nexport function sighash(nameSpace, ixName) {\n  var name = snakeCase(ixName);\n  var preimage = \"\".concat(nameSpace, \":\").concat(name);\n  return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}","map":{"version":3,"sources":["../../../src/coder/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { snakeCase } from \"snake-case\";\nimport { sha256 } from \"js-sha256\";\nimport { IdlError } from \"../error\";\nexport function accountSize(idl, idlAccount) {\n    if (idlAccount.type.kind === \"enum\") {\n        let variantSizes = idlAccount.type.variants.map((variant) => {\n            if (variant.fields === undefined) {\n                return 0;\n            }\n            return (variant.fields\n                // @ts-ignore\n                .map((f) => {\n                // @ts-ignore\n                if (f.name === undefined) {\n                    throw new Error(\"Tuple enum variants not yet implemented.\");\n                }\n                // @ts-ignore\n                return typeSize(idl, f.type);\n            })\n                .reduce((a, b) => a + b));\n        });\n        return Math.max(...variantSizes) + 1;\n    }\n    if (idlAccount.type.fields === undefined) {\n        return 0;\n    }\n    return idlAccount.type.fields\n        .map((f) => typeSize(idl, f.type))\n        .reduce((a, b) => a + b);\n}\n// Returns the size of the type in bytes. For variable length types, just return\n// 1. Users should override this value in such cases.\nfunction typeSize(idl, ty) {\n    switch (ty) {\n        case \"bool\":\n            return 1;\n        case \"u8\":\n            return 1;\n        case \"i8\":\n            return 1;\n        case \"i16\":\n            return 2;\n        case \"u16\":\n            return 2;\n        case \"u32\":\n            return 4;\n        case \"i32\":\n            return 4;\n        case \"u64\":\n            return 8;\n        case \"i64\":\n            return 8;\n        case \"u128\":\n            return 16;\n        case \"i128\":\n            return 16;\n        case \"bytes\":\n            return 1;\n        case \"string\":\n            return 1;\n        case \"publicKey\":\n            return 32;\n        default:\n            // @ts-ignore\n            if (ty.vec !== undefined) {\n                return 1;\n            }\n            // @ts-ignore\n            if (ty.option !== undefined) {\n                // @ts-ignore\n                return 1 + typeSize(idl, ty.option);\n            }\n            // @ts-ignore\n            if (ty.defined !== undefined) {\n                // @ts-ignore\n                const filtered = idl.types.filter((t) => t.name === ty.defined);\n                if (filtered.length !== 1) {\n                    throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n                }\n                let typeDef = filtered[0];\n                return accountSize(idl, typeDef);\n            }\n            // @ts-ignore\n            if (ty.array !== undefined) {\n                // @ts-ignore\n                let arrayTy = ty.array[0];\n                // @ts-ignore\n                let arraySize = ty.array[1];\n                // @ts-ignore\n                return typeSize(idl, arrayTy) * arraySize;\n            }\n            throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n    }\n}\n// Not technically sighash, since we don't include the arguments, as Rust\n// doesn't allow function overloading.\nexport function sighash(nameSpace, ixName) {\n    let name = snakeCase(ixName);\n    let preimage = `${nameSpace}:${name}`;\n    return Buffer.from(sha256.digest(preimage)).slice(0, 8);\n}\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}